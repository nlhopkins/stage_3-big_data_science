# Extract the Kd from the NLS for inline reporting.
kd <- summary(NLS(emsa))$coefficients[2, 1]
# Linear regression of the EMSA calibration data rf ~ log. Coefficients will be used to predict the size of HiGam + DNA.
emsa_lm <- lm(emsa_calibration$rf ~ emsa_calibration$log)
# Predict footpring using predicted HiGam size (y=mx+c), the avg weight of 500bp DNA (330000), and the weight of dimeric HiGam (30626.5 / 2).
emsa <- emsa %>%
mutate(log = ((rf * as.numeric(
emsa_lm$coefficients[2]
)) + as.numeric(emsa_lm$coefficients[1])),
actual_weight = 10^log)
emsa_footprint <- (500 / abs(((max(emsa$log) - 330000)) / (30626.5 / 2)))
emsa_plot <- emsa %>%
ggplot(aes(x = conc, y = rf)) +
geom_point(shape = 20,
size = 3) +
stat_function(fun = emsa_pred_intercept, colour = "#66C2A4") +
mytheme() +
scale_y_continuous(
expand = c(0.02, 0.02),
limits = c(0.3, 0.7),
breaks = seq(0.3, 0.7, by = 0.20)
) +
scale_x_continuous(
expand = c(0.02, 0.02),
limits = c(0, 4),
breaks = seq(0, 8, by = 1)
) +
xlab(NULL) +
ylab(expression(paste(bold(
"Relative Front (a.U.)"
))))
# Plot the residuals and a line showing y = 0
emsa_res_plot <- emsa %>%
ggplot(aes(x = conc, y = residuals)) +
geom_point(shape = 20,
size = 3,
colour = "#5a5a5a") +
geom_hline(aes(yintercept = 0),
col = '#66C2A4',
size = .5) +
scale_x_continuous(
expand = c(0.02, 0.02),
limits = c(0, 4),
breaks = seq(0, 8, by = 1),
name = (expression(bold(
atop("Protein Concentration (μM)", "Im9"["dimer"])
)))
) +
scale_y_continuous(
expand = c(0.02, 0.02),
limits = c(-0.1, 0.1),
breaks = seq(-0.1, 0.1, by = 0.1),
name = "Residual (a.U.)"
) + mytheme()
emsa_full <- ggarrange(
emsa_plot,
emsa_res_plot,
nrow = 2,
ncol = 1,
widths = c(2, 1 / 2)
)
emsa_full
ggsave("figures/emsa_plot.pdf", plot = emsa_full,
height = 15,
width = 20, unit = "cm")
emsa
# EMSA Dataset
emsa %>%
select(-gel_length, -log) %>%
knitr::kable(
digits = 2,
col.names = c("Concentration",
"Distance",
"Relative Front",
"Residuals",
"Actual Weight")
) %>%
kable_styling(font_size = 15, position = "center")
10^emsa$log
# Linear regression of the EMSA calibration data rf ~ log. Coefficients will be used to predict the size of HiGam + DNA.
emsa_lm <- lm(emsa_calibration$rf ~ emsa_calibration$log)
# Predict footpring using predicted HiGam size (y=mx+c), the avg weight of 500bp DNA (330000), and the weight of dimeric HiGam (30626.5 / 2).
emsa <- emsa %>%
mutate(log = ((rf * as.numeric(
emsa_lm$coefficients[2]
)) + as.numeric(emsa_lm$coefficients[1])),
actual_weight = 10^emsa$log)
emsa_footprint <- (500 / abs(((max(emsa$log) - 330000)) / (30626.5 / 2)))
emsa
emsa_lm
# Linear regression of the EMSA calibration data rf ~ log. Coefficients will be used to predict the size of HiGam + DNA.
emsa_lm <- lm(emsa_calibration$rf ~ emsa_calibration$log)
emsa_lm
emsa_calibration
# Prepare the calibration data by calculating the Rf and log10(expected size)
emsa_calibration <-
emsa_calibration %>% mutate(log = log(expected_size),
rf = relative_front(emsa_calibration))
# Prepare the PCR dataset for analysis by calculating the relative front.
emsa <-
emsa %>% mutate(rf = (relative_front(emsa))) # calculate the relative front
# Prepare the calibration data by calculating the Rf and log10(expected size)
emsa_calibration <-
emsa_calibration %>% mutate(log = log10(expected_size),
rf = relative_front(emsa_calibration))
# Prepare the PCR dataset for analysis by calculating the relative front.
emsa <-
emsa %>% mutate(rf = (relative_front(emsa))) # calculate the relative front
emsa_calibration
# Prepare the calibration data by calculating the Rf and log10(expected size)
emsa_calibration <-
emsa_calibration %>% mutate(log = log10(expected_size),
rf = relative_front(emsa_calibration))
# Prepare the PCR dataset for analysis by calculating the relative front.
emsa <-
emsa %>% mutate(rf = (relative_front(emsa))) # calculate the relative front
# Calculate the difference between the measured rf and predicted rf value
# This is needed for the residuals
# Calculate residuals to the fit
emsa <- emsa %>%
mutate(residuals = rf - predict(NLS(emsa)))
# Extract the Kd from the NLS for inline reporting.
kd <- summary(NLS(emsa))$coefficients[2, 1]
# Linear regression of the EMSA calibration data rf ~ log. Coefficients will be used to predict the size of HiGam + DNA.
emsa_lm <- lm(emsa_calibration$rf ~ emsa_calibration$log)
# Predict footpring using predicted HiGam size (y=mx+c), the avg weight of 500bp DNA (330000), and the weight of dimeric HiGam (30626.5 / 2).
emsa <- emsa %>%
mutate(log = ((rf * as.numeric(
emsa_lm$coefficients[2]
)) + as.numeric(emsa_lm$coefficients[1])),
actual_weight = 10^emsa$log)
emsa_footprint <- (500 / abs(((max(emsa$log) - 330000)) / (30626.5 / 2)))
actual_weight = 10^emsa$log)
actual_weight = 10^(emsa$log)
actual_weight = 10^(emsa$log)
10^(emsa$log)
emsa_lm
# Linear regression of the EMSA calibration data rf ~ log. Coefficients will be used to predict the size of HiGam + DNA.
emsa_lm <- lm(emsa_calibration$log ~ emsa_calibration$rf)
emsa_lm
# Linear regression of the EMSA calibration data rf ~ log. Coefficients will be used to predict the size of HiGam + DNA.
emsa_lm <- lm(emsa_calibration$log ~ emsa_calibration$rf)
# Predict footpring using predicted HiGam size (y=mx+c), the avg weight of 500bp DNA (330000), and the weight of dimeric HiGam (30626.5 / 2).
emsa <- emsa %>%
mutate(log = ((rf * as.numeric(
emsa_lm$coefficients[2]
)) + as.numeric(emsa_lm$coefficients[1])),
actual_weight = 10^emsa$log)
emsa_footprint <- (500 / abs(((max(emsa$log) - 330000)) / (30626.5 / 2)))
emsa_footprint
emsa
# Linear regression of the EMSA calibration data rf ~ log. Coefficients will be used to predict the size of HiGam + DNA.
emsa_lm <- lm(emsa_calibration$log ~ emsa_calibration$rf)
# Predict footpring using predicted HiGam size (y=mx+c), the avg weight of 500bp DNA (330000), and the weight of dimeric HiGam (30626.5 / 2).
emsa <- emsa %>%
mutate(log = ((rf * as.numeric(
emsa_lm$coefficients[2]
)) + as.numeric(emsa_lm$coefficients[1])))
emsa_footprint <- (500 / abs(((max(emsa$log) - 330000)) / (30626.5 / 2)))
knitr::opts_chunk$set(
include = FALSE,
echo = FALSE,
fig.align = "center",
fig.retina = 3,
message = FALSE,
warning = FALSE)
# Load the tidyverse. Functions are used for tidying data and creating plots via ggplot2.
library(tidyverse)
# Load plotly. Plotly converts static ggplot to an interactive plot.
library(plotly)
# Load ggpubr. Combines multiple ggplots into a single plot.
library(ggpubr)
# Load RefManageR. Provides tools for importing and working with bibliographic references.
library(RefManageR)
# Load kableExtra. Table generation.
library(kableExtra)
# Load showtext. Allows use of Google fonts in ggplots.
library(showtext)
# Load wordcountaddin. Counts words and characters in text in an R markdown document.
library(wordcountaddin)
# Importing custom themes and fonts.
font_add_google("Montserrat", "Montserrat")
# turn on showtext
showtext_auto()
source("R/themes.R", local = knitr::knit_global())
# Biblopgraphy and in-text citation settings
RefManageR::BibOptions(
check.entries = FALSE,
bib.style = "authoryear",
cite.style = "numeric",
style = "markdown",
hyperlink = "to.doc",
dashed = FALSE,
longnamesfirst = FALSE,
max.names = 2
)
# Read in references for packages and literature/tools.
refs <-
RefManageR::ReadBib("bibliography/refs.bib", check = FALSE)
pkgs <-
RefManageR::ReadBib("bibliography/pkgs.bib", check = FALSE)
knitr::include_graphics("images/mu_transposition.jpg")
# Source functions
source("functions/relative_front.R", local = knitr::knit_global()) # Calculate relative front
source("functions/nls.R", local = knitr::knit_global()) # Performs the NLS using the Langmuir binding isotherm (NLS)
source("functions/emsa_pred_intercept.R", local = knitr::knit_global()) # Predicts the intercept of the EMSA data
source("functions/sec_pred_intercept.R", local = knitr::knit_global()) # Predicts the intercept of the SEC data
source("functions/sec_mw.R", local = knitr::knit_global()) # SEC molecular weights
source("functions/sec_elution.R", local = knitr::knit_global()) # Extracting elution times from SEC analysis.
# Source raw data files and tidy heading names.
# Load the PCR data
pcr <- read.csv("data/data-raw/pcr.csv", header = TRUE) %>%
janitor::clean_names()
# Load the PCR calibration data for the gDNA library
gdna_calibration <-
read.csv("data/data-raw/pcr_gdna_calibration.csv", header = TRUE) %>%
janitor::clean_names()
# Load the PCR calibration data for the cDNA library
cdna_calibration <-
read.csv("data/data-raw/pcr_cdna_calibration.csv", header = TRUE) %>%
janitor::clean_names()
# Load the EMSA data
emsa <- read.csv("data/data-raw/emsa.csv", header = TRUE) %>%
janitor::clean_names()
# Load the EMSA calibration data
emsa_calibration <-
read.csv("data/data-raw/emsa_calibration.csv", header = TRUE) %>%
janitor::clean_names()
# Load the SEC standards data
standards <-
read.csv("data/data-raw/sec_std.csv", header = TRUE) %>%
janitor::clean_names()
# Load the SEC data
sec <-
read.csv("data/data-raw/sec_im9higam.csv", header = TRUE) %>%
janitor::clean_names()
# Load the SDS Paage data
sds <-
read.csv("data/data-raw/sds.csv", header = TRUE) %>%
janitor::clean_names()
# Load the SDS Calibration data
sds_calibration <-
read.csv("data/data-raw/sds_calibration.csv", header = TRUE) %>%
janitor::clean_names()
# Prepare data by tidying where neccessary.
# Rename the proteins and pivot them
standards <- standards %>%
rename(
c(
"Ferritin" = curve_ferritin,
"IgG" = curve_ig_g,
"Myoglobin" = curve_myoglobin,
"Ovalbumin" = curve_ovalbumin,
"Thyroglobulin" = curve_thyroglobulin,
"Transferrin" = curve_transferrin,
"Vitamin B12" = curve_vitamin_b12
)
) %>%
pivot_longer(cols = !c(x, vol),
names_to = "protein",
values_to = "absorbance_units")
# Pivot proteins
sec <- sec %>%
pivot_longer(cols = starts_with("a"),
names_to = "protein",
values_to = "absorbance")
# Separate the PCR data set by DNA library for analysis
gdna <- pcr %>% # gDNA PCR data
filter(library == "gDNA")
cdna <- pcr %>% # cDNA PCR data
filter(library == "cDNA")
knitr::include_graphics("images/align.png")
knitr::include_graphics("images/map.png")
# Creating a table for the alignments obtained in BLAST
data.frame(
"amplicon" = c("HiA", "HiB", "HiGam"),
"e_value" = c("2e-149", "5e-86", "4e-70"),
"percent_identity" = c("39.61", "46.44", "60.53")
) %>%
knitr::kable(
caption = " Mu homologues in H. influenzae were aligned in BLAST, identifying HiA, HiB, and HiGam. Their E values and percent identity are consistent with them being homologues of Mu.",
digits = 2,
col.names = c("Amplicon",
"E Value",
"Percent Identity (%)")
) %>%
kable_styling(font_size = 15)
# Linear regression models on the PCR calibration data. We can predict our PCR amplicon sizes based on these using y = mx+c.
#gDNA
gdna_mod <- lm(data = gdna_calibration, log ~ rf)
#cDNA
cdna_mod <- lm(data = cdna_calibration, log ~ rf)
# Calculate the relative front (Rf), log = (y=mx+c), actual amplicon size, and percentage difference to the predicted size.
# gDNA
gdna <- gdna %>%
mutate(
rf = relative_front(gdna),
# calculate the Rf
log = ((rf * gdna_mod$coefficients[2]) + gdna_mod$coefficients[1]),
# log = (y = mx+c)
actual_size = (10 ^ log),
# actual gene size = 10^log
diff = ((expected_size - actual_size) / expected_size * 100) # % difference between expected and actual sizes
)
# cDNA
cdna <- cdna %>%
mutate(
rf = relative_front(cdna),
# calculate the Rf
log = ((rf * cdna_mod$coefficients[2]) + cdna_mod$coefficients[1]),
# log = (y = mx+c)
actual_size = (10 ^ log),
# actual gene size = 10^log
diff = ((expected_size - actual_size) / expected_size * 100) # % difference between expected and actual sizes
)
# Join gDNA & cDNA datasets for visualisation later on
pcr_full <- full_join(gdna, cdna, by = NULL)
# ggplot2 column plot of the merged PCR data showing the expressed genes and the percentage difference of actual size to expected size.
pcr_plot <- pcr_full %>%
ggplot(aes(
x = gene,
y = diff,
fill = library,
text = paste(
"Library: ",
library,
"<br>Amplicon: ",
gene,
"<br>Difference: ",
round(diff),
"%",
"<br>Expected Size (bp): ",
expected_size,
"<br>Actual Size (bp):",
round(actual_size)
)
)) + geom_col(position = "dodge") +
geom_hline(yintercept = 0, size = 0.25) +
mytheme() +
scale_fill_brewer(name = "DNA Library",
labels = c("cDNA", "gDNA"),
palette = "Set3",
) +
labs(y = "Percentage Difference to Expected Size",
x = "Amplicon")
ggsave(
"figures/pcr_plot.pdf",
plot = pcr_plot,
height = 15,
width = 20,
unit = "cm"
)
# Make this interactive
ggplotly(pcr_plot, tooltip = c("text"), align = "center")
knitr::include_graphics("images/pcr.png")
# Kable table of the full PCR dataset with the calculated values.
pcr_full %>%
select(-primer, -gel_length) %>%
knitr::kable(
caption = "The actual amplicon sizes were calculated using the linear regression equation \\@ref(eq:log) acquired by linear regression analysis of the PCR ladder bands. Size Difference compares the expected and actual amplicon sizes.",
booktabs = T,
digits = 2,
col.names = c(
"Library",
"Amplicon",
"Distance (cm)",
"Expected Size (bp)",
"Relative Front (Rf)",
"Log(Rf)",
"Actual Size (bp)",
"Size Difference (%)"
)
) %>%
collapse_rows(columns = 1) %>%
kable_styling(font_size = 15, position = "center")
knitr::include_graphics("images/western_blot.png")
# Calculate the relative front and log10 weight for the SDS calibration data.
sds_calibration <- sds_calibration %>%
mutate(rf = (
(sds_calibration$gel_length - sds_calibration$distance) / sds_calibration$gel_length
),
log = log10(weight_da))
# Linear model of SDS log ~ rf to use in y=mx+c to predict sample weights.
sds_mod <- lm(sds_calibration$log ~ sds_calibration$rf)
# Calculate the relative front (Rf), log = y=mx+c, 10^log = actual weight, and percentage difference to the predicted weight for the samples.
sds <- sds %>%
mutate(
rf = ((gel_length - distance) / gel_length),
log = ((rf * sds_mod$coefficients[2]) + sds_mod$coefficients[1]),
actual_weight = 10 ^ log,
diff = ((expected_weight - actual_weight) / expected_weight) * 100
)
# Kable table of the SDS data with calculated values.
sds %>% select(-log, -gel_length, -distance) %>%
knitr::kable(
caption = "Molecular weight was determined using Rf of bands and the linear regression equation acquired by the linear regression analysis of the MW ladder bands. Expected weights were obtained by ExPASy ProtParam.",
booktabs = T,
digits = 2,
col.names = c(
"Column",
"Sample",
"Expected Weight (Da)",
"Relative Front (Rf)",
"Actual Weight (Da)",
"Size Difference (%)"
)
) %>%
collapse_rows(columns = 3) %>%
kable_styling(font_size = 15, position = "center")
# Prepare the calibration data by calculating the Rf and log10(expected size)
emsa_calibration <-
emsa_calibration %>% mutate(log = log10(expected_size),
rf = relative_front(emsa_calibration))
# Prepare the PCR dataset for analysis by calculating the relative front.
emsa <-
emsa %>% mutate(rf = (relative_front(emsa))) # calculate the relative front
# Calculate the difference between the measured rf and predicted rf value
# This is needed for the residuals
# Calculate residuals to the fit
emsa <- emsa %>%
mutate(residuals = rf - predict(NLS(emsa)))
# Extract the Kd from the NLS for inline reporting.
kd <- summary(NLS(emsa))$coefficients[2, 1]
# Linear regression of the EMSA calibration data rf ~ log. Coefficients will be used to predict the size of HiGam + DNA.
emsa_lm <- lm(emsa_calibration$log ~ emsa_calibration$rf)
# Predict footpring using predicted HiGam size (y=mx+c), the avg weight of 500bp DNA (330000), and the weight of dimeric HiGam (30626.5 / 2).
emsa <- emsa %>%
mutate(log = ((rf * as.numeric(
emsa_lm$coefficients[2]
)) + as.numeric(emsa_lm$coefficients[1])))
emsa_footprint <- (500 / abs(((max(emsa$log) - 330000)) / (30626.5 / 2)))
emsa_plot <- emsa %>%
ggplot(aes(x = conc, y = rf)) +
geom_point(shape = 20,
size = 3) +
stat_function(fun = emsa_pred_intercept, colour = "#66C2A4") +
mytheme() +
scale_y_continuous(
expand = c(0.02, 0.02),
limits = c(0.3, 0.7),
breaks = seq(0.3, 0.7, by = 0.20)
) +
scale_x_continuous(
expand = c(0.02, 0.02),
limits = c(0, 4),
breaks = seq(0, 8, by = 1)
) +
xlab(NULL) +
ylab(expression(paste(bold(
"Relative Front (a.U.)"
))))
# Plot the residuals and a line showing y = 0
emsa_res_plot <- emsa %>%
ggplot(aes(x = conc, y = residuals)) +
geom_point(shape = 20,
size = 3,
colour = "#5a5a5a") +
geom_hline(aes(yintercept = 0),
col = '#66C2A4',
size = .5) +
scale_x_continuous(
expand = c(0.02, 0.02),
limits = c(0, 4),
breaks = seq(0, 8, by = 1),
name = (expression(bold(
atop("Protein Concentration (μM)", "Im9"["dimer"])
)))
) +
scale_y_continuous(
expand = c(0.02, 0.02),
limits = c(-0.1, 0.1),
breaks = seq(-0.1, 0.1, by = 0.1),
name = "Residual (a.U.)"
) + mytheme()
emsa_full <- ggarrange(
emsa_plot,
emsa_res_plot,
nrow = 2,
ncol = 1,
widths = c(2, 1 / 2)
)
emsa_full
ggsave("figures/emsa_plot.pdf", plot = emsa_full,
height = 15,
width = 20, unit = "cm")
# EMSA Dataset
emsa %>%
select(-gel_length) %>%
knitr::kable(
digits = 2,
col.names = c("Concentration",
"Distance",
"Relative Front",
"Residuals",
"Actual Weight")
) %>%
kable_styling(font_size = 15, position = "center")
# Predict footpring using predicted HiGam size (y=mx+c), the avg weight of 500bp DNA (330000), and the weight of dimeric HiGam (30626.5 / 2).
emsa <- emsa %>%
mutate(log = 1000 * ((rf * as.numeric(
emsa_lm$coefficients[2]
)) + as.numeric(emsa_lm$coefficients[1])))
emsa
emsa_footprint <- (500 / abs(((max(emsa$log) - 330000)) / (30626.5 / 2)))
emsa_footprint
# Predict footpring using predicted HiGam size (y=mx+c), the avg weight of 500bp DNA (330000), and the weight of dimeric HiGam (30626.5 / 2).
emsa <- emsa %>%
mutate(log = 1000 * ((rf * as.numeric(
emsa_lm$coefficients[2]
)) + as.numeric(emsa_lm$coefficients[1])))
emsa_footprint
emsa
