cdna_calibration <-
read.csv("../data/data-raw/pcr_cdna_calibration.csv", header = TRUE) %>%
janitor::clean_names()
# Load the EMSA data
emsa <- read.csv("../data/data-raw/emsa.csv", header = TRUE) %>%
janitor::clean_names()
# Load the EMSA calibration data
emsa_calibration <-
read.csv("../data/data-raw/emsa_calibration.csv", header = TRUE) %>%
janitor::clean_names()
# Load the SEC standards data
standards <-
read.csv("../data/data-raw/sec_std.csv", header = TRUE) %>%
janitor::clean_names()
# Load the SEC data
sec <-
read.csv("../data/data-raw/sec_im9higam.csv", header = TRUE) %>%
janitor::clean_names()
# Load the SDS Paage data
sds <-
read.csv("../data/data-raw/sds.csv", header = TRUE) %>%
janitor::clean_names()
# Load the SDS Calibration data
sds_calibration <-
read.csv("../data/data-raw/sds_calibration.csv", header = TRUE) %>%
janitor::clean_names()
# Prepare data by tidying where neccessary.
# Rename the proteins and pivot them
standards <- standards %>%
rename(
c(
"Ferritin" = curve_ferritin,
"IgG" = curve_ig_g,
"Myoglobin" = curve_myoglobin,
"Ovalbumin" = curve_ovalbumin,
"Thyroglobulin" = curve_thyroglobulin,
"Transferrin" = curve_transferrin,
"Vitamin B12" = curve_vitamin_b12
)
) %>%
pivot_longer(cols = !c(x, vol),
names_to = "protein",
values_to = "absorbance_units")
# Pivot proteins
sec <- sec %>%
pivot_longer(cols = starts_with("a"),
names_to = "protein",
values_to = "absorbance")
# Separate the PCR data set by DNA library for analysis
gdna <- pcr %>% # gDNA PCR data
filter(library == "gDNA")
cdna <- pcr %>% # cDNA PCR data
filter(library == "cDNA")
knitr::include_graphics("../images/align_hi.png")
knitr::include_graphics("../images/map.png")
# Creating a table for the alignments obtained in BLAST
blast_hi <- data.frame(
"amplicon" = c("HiA", "HiB", "HiGam"),
"e_value" = c("2e-149", "5e-86", "4e-70"),
"percent_identity" = c("39.61", "46.44", "60.53")
)
blast_hi %>%
knitr::kable(
caption = " Mu homologues in H. influenzae were aligned in BLAST, identifying HiA, HiB, and HiGam. Their E values and percent identity are consistent with them being homologues of Mu.",
digits = 2,
col.names = c("Amplicon",
"E Value",
"Percent Identity (%)")
) %>%
kable_styling(font_size = 15)
# Save processed Blast data
write.csv(blast_hi, '../data/data-processed/blast_hi.csv')
# Linear regression models on the PCR calibration data. We can predict our PCR amplicon sizes based on these using y = mx+c.
#gDNA
gdna_mod <- lm(data = gdna_calibration, log ~ rf)
#cDNA
cdna_mod <- lm(data = cdna_calibration, log ~ rf)
# Calculate the relative front (Rf), log = (y=mx+c), actual amplicon size, and percentage difference to the predicted size.
# gDNA
gdna <- gdna %>%
mutate(
rf = relative_front(gdna),
# calculate the Rf
log = ((rf * gdna_mod$coefficients[2]) + gdna_mod$coefficients[1]),
# log = (y = mx+c)
actual_size = (10 ^ log),
# actual gene size = 10^log
diff = ((expected_size - actual_size) / expected_size * 100) # % difference between expected and actual sizes
)
# cDNA
cdna <- cdna %>%
mutate(
rf = relative_front(cdna),
# calculate the Rf
log = ((rf * cdna_mod$coefficients[2]) + cdna_mod$coefficients[1]),
# log = (y = mx+c)
actual_size = (10 ^ log),
# actual gene size = 10^log
diff = ((expected_size - actual_size) / expected_size * 100) # % difference between expected and actual sizes
)
# Join gDNA & cDNA datasets for visualisation later on
pcr_full <- full_join(gdna, cdna, by = NULL)
# Save processed PCR data
write.csv(pcr_full, '../data/data-processed/pcr.csv')
# ggplot2 column plot of the merged PCR data showing the expressed genes and the percentage difference of actual size to expected size.
pcr_plot <- pcr_full %>%
ggplot(aes(
x = gene,
y = diff,
fill = library,
text = paste(
"Library: ",
library,
"<br>Amplicon: ",
gene,
"<br>Difference: ",
round(diff),
"%",
"<br>Expected Size (bp): ",
expected_size,
"<br>Actual Size (bp):",
round(actual_size)
)
)) + geom_col(position = "dodge") +
geom_hline(yintercept = 0, size = 0.25) +
mytheme() +
scale_fill_brewer(name = "DNA Library",
labels = c("cDNA", "gDNA"),
palette = "Set3",) +
labs(y = "Percentage Difference to Expected Size",
x = "Amplicon")
ggsave(
"../figures/pcr_plot.pdf",
plot = pcr_plot,
height = 15,
width = 20,
unit = "cm"
)
# Make this interactive
ggplotly(pcr_plot, tooltip = c("text"), align = "center")
knitr::include_graphics("../images/pcr.png")
# Kable table of the full PCR dataset with the calculated values.
pcr_full %>%
select(-primer, -gel_length) %>%
knitr::kable(
caption = "The actual amplicon sizes were calculated using the linear regression equation \\@ref(eq:log) acquired by linear regression analysis of the PCR ladder bands. Size Difference compares the expected and actual amplicon sizes.",
booktabs = T,
digits = 2,
col.names = c(
"Library",
"Amplicon",
"Distance (cm)",
"Expected Size (bp)",
"Relative Front (Rf)",
"Log(Rf)",
"Actual Size (bp)",
"Size Difference (%)"
)
) %>%
collapse_rows(columns = 1) %>%
kable_styling(font_size = 15, position = "center")
knitr::include_graphics("../images/western_blot.png")
# Calculate the relative front and log10 weight for the SDS calibration data.
sds_calibration <- sds_calibration %>%
mutate(rf = (
(sds_calibration$gel_length - sds_calibration$distance) / sds_calibration$gel_length
),
log = log10(weight_da))
# Save processed sds data
write.csv (sds_calibration,
'../data/data-processed/sds_calibration.csv')
# Linear model of SDS log ~ rf to use in y=mx+c to predict sample weights.
sds_mod <- lm(sds_calibration$log ~ sds_calibration$rf)
# Calculate the relative front (Rf), log = y=mx+c, 10^log = actual weight, and percentage difference to the predicted weight for the samples.
sds <- sds %>%
mutate(
rf = ((gel_length - distance) / gel_length),
log = ((rf * sds_mod$coefficients[2]) + sds_mod$coefficients[1]),
actual_weight = 10 ^ log,
diff = ((expected_weight - actual_weight) / expected_weight) * 100
)
# Kable table of the SDS data with calculated values.
sds %>% select(-log, -gel_length, -distance) %>%
knitr::kable(
caption = "Molecular weight was determined using Rf of bands and the linear regression equation acquired by the linear regression analysis of the MW ladder bands. Expected weights were obtained by ExPASy ProtParam.",
booktabs = T,
digits = 2,
col.names = c(
"Column",
"Sample",
"Expected Weight (Da)",
"Relative Front (Rf)",
"Actual Weight (Da)",
"Size Difference (%)"
)
) %>%
collapse_rows(columns = 3) %>%
kable_styling(font_size = 15, position = "center")
# Prepare the calibration data by calculating the Rf and log10(expected size)
emsa_calibration <-
emsa_calibration %>% mutate(log = log10(expected_size),
rf = relative_front(emsa_calibration))
# Prepare the PCR dataset for analysis by calculating the relative front.
emsa <-
emsa %>% mutate(rf = (relative_front(emsa))) # calculate the relative front
# Calculate the difference between the measured rf and predicted rf value
# This is needed for the residuals
# Calculate residuals to the fit
emsa <- emsa %>%
mutate(residuals = rf - predict(NLS(emsa)))
# Save processed data
write.csv (emsa, '../data/data-processed/emsa.csv')
# Extract the Kd from the NLS for inline reporting.
kd <- summary(NLS(emsa))$coefficients[2, 1]
# Linear regression of the EMSA calibration data rf ~ log. Coefficients will be used to predict the size of HiGam + DNA.
emsa_lm <- lm(emsa_calibration$log ~ emsa_calibration$rf)
# Predict footpring using predicted HiGam size (y=mx+c), the avg weight of 500bp DNA (330000), and the weight of dimeric HiGam (30626.5 / 2).
emsa <- emsa %>%
mutate(log = 1000 * ((rf * as.numeric(
emsa_lm$coefficients[2]
)) + as.numeric(emsa_lm$coefficients[1])))
emsa_footprint <-
(500 / abs(((
max(emsa$log) - 330000
)) / (30626.5 / 2)))
emsa_plot <- emsa %>%
ggplot(aes(x = conc, y = rf)) +
geom_point(shape = 20,
size = 3) +
stat_function(fun = emsa_pred_intercept, colour = "#66C2A4") +
mytheme() +
scale_y_continuous(
expand = c(0.02, 0.02),
limits = c(0.3, 0.7),
breaks = seq(0.3, 0.7, by = 0.20)
) +
scale_x_continuous(
expand = c(0.02, 0.02),
limits = c(0, 4),
breaks = seq(0, 8, by = 1)
) +
xlab(NULL) +
ylab(expression(paste(bold(
"Relative Front (a.U.)"
))))
# Plot the residuals and a line showing y = 0
emsa_res_plot <- emsa %>%
ggplot(aes(x = conc, y = residuals)) +
geom_point(shape = 20,
size = 3,
colour = "#5a5a5a") +
geom_hline(aes(yintercept = 0),
col = '#66C2A4',
size = .5) +
scale_x_continuous(
expand = c(0.02, 0.02),
limits = c(0, 4),
breaks = seq(0, 8, by = 1),
name = (expression(bold(
atop("Protein Concentration (Î¼M)", "Im9"["dimer"])
)))
) +
scale_y_continuous(
expand = c(0.02, 0.02),
limits = c(-0.1, 0.1),
breaks = seq(-0.1, 0.1, by = 0.1),
name = "Residual (a.U.)"
) + mytheme()
emsa_full <- ggarrange(
emsa_plot,
emsa_res_plot,
nrow = 2,
ncol = 1,
widths = c(2, 1 / 2)
)
emsa_full
ggsave(
"../figures/emsa_plot.pdf",
plot = emsa_full,
height = 15,
width = 20,
unit = "cm"
)
# Kable table of the EMSA Dataset
emsa %>%
select(-gel_length) %>%
knitr::kable(
digits = 2,
col.names = c(
"Concentration",
"Distance",
"Relative Front",
"Residuals",
"Actual Weight (Da)"
)
) %>%
kable_styling(font_size = 15, position = "center")
# Prepare the standards data
sec_standards <- standards %>%
group_by(protein) %>%
filter(absorbance_units == max(absorbance_units)) %>% # filter by the maximum absorbency units
summarise(vol) %>%
ungroup() %>%
mutate(
mw = recode(
# Add a column for the molecular weights of each protein
# Protein MWs
protein,
"Thyroglobulin" = 669000,
"Ferritin" = 440000,
"IgG" = 150000,
"Transferrin" = 81000,
"Ovalbumin" = 43000,
"Myoglobin" = 17000,
"Vitamin B12" = 1355
),
logmw = log(mw) # log10 of the MW
)
# Save processed data
write.csv(sec_standards, '../data/data-processed/sec_standards.csv')
# Getting the elution volume that corresponds to the maximum value of a curve
# a280 elution volume
a280_elution <-
format(round(sec_elution("a280"), digits = 2), scientific = FALSE)
# a254 elution volume
a254_elution <-
format(round(sec_elution("a254"), digits = 2), scientific = FALSE)
# Getting the molecular weight for the max elution for each wavelength using the sec_mw function
# a280 mw
a280_mw <- sec_mw("a280") # protein
# a254 mw
a254_mw <- sec_mw("a254") # protein + DNA
# Footprint size estimated by SEC
# footprint = a245 (protein + DNA) - a280 (protein) / avg base pair weight (660)
sec_footprint <-
as.numeric(round((a254_mw - a280_mw) / 660, digits = 2))
# Format mws for inline reporting
a280_mw <- format(round(a280_mw, digits = 2), scientific = FALSE)
a254_mw <- format(round(a254_mw, digits = 2), scientific = FALSE)
# Plot of the standards elution volumes
sec_plot <- sec %>%
mutate(protein = recode(protein, "a280" = "A280", "a254" = "A254")) %>%
ggplot(aes(x = vol,
y = absorbance,
colour = protein),
show.legend = TRUE) +
geom_line() +
scale_colour_brewer(name = "Protein",
palette = "Set2") +
scale_x_continuous(limits = c(13, 17)) +
scale_y_continuous(expand = c(0, 0),
limits = c(0, 100)) +
mytheme() +
xlab("Elution Volume (mL)") +
ylab("Absorbance (mAU)")
ggsave(
"../figures/sec_plot.pdf",
height = 15,
width = 20,
unit = "cm"
)
# make plot interactive with ggplotly
ggplotly(align = "center")
# Plot the SEC standards
standards_plot <- standards %>%
ggplot(aes(x = vol,
y = absorbance_units,
colour = protein),
show.legend = TRUE) +
geom_line() +
scale_colour_brewer(name = "Protein",
palette = "Set2") + # colour blind friendly
mytheme() +
scale_x_continuous(
expand = c(0, 0),
limits = c(9, 22),
breaks = seq(9, 22, by = 1),
name = "Elution Volume (mL)"
) + scale_y_continuous(
expand = c(0, 0),
limits = c(0, 100),
breaks = seq(0, 100, by = 10),
name = "A280 Absorbance Units (A.U.)"
)
# Make this interactive
ggplotly(standards_plot)
# Save the plot as an image
ggsave(
"../figures/standards_plot.pdf",
plot = standards_plot,
height = 15,
width = 20,
unit = "cm"
)
# Plot the standards elution against MW and predict the intercept using sec_pred_intercept function
sec_std_plot <- sec_standards %>%
ggplot(mapping = aes(y = vol, x = logmw)) +
geom_point() +
stat_function(fun = sec_pred_intercept, # Cannot be made interactive as stat_function incompatible
geom = "line",
colour = "#8D9FCA") +
mytheme() +
scale_x_continuous(
expand = c(0.05, 0.05),
limits = c(7, 14),
breaks = seq(7, 14, by = 1),
name = "Log (MW)"
) + scale_y_continuous(
expand = c(0.05, 0.05),
limits = c(10, 22),
breaks = seq(10, 22, by = 2),
name = "Elution Volume (mL)"
)
sec_std_plot
# Save plot as an image
ggsave(
"../figures/sec_std_plot.pdf",
plot = sec_std_plot,
height = 15,
width = 20,
unit = "cm"
)
# Plot the processed SEC data into a Kable table
sec %>%
select(-x) %>%
pivot_wider(names_from = "protein", # pivot to make more human-readable
values_from = "absorbance") %>%
knitr::kable(
booktabs = T,
digits = 2,
col.names = c("Volume",
"A254",
"A280")
) %>%
kable_styling(font_size = 15) %>%
scroll_box(height = "300px")
# Save processed data
write.csv(sec, '../data/data-processed/sec.csv')
knitr::include_graphics("../images/ku.png")
# Create a dataframe for the output of the BLAST alignments
blast_mu <- data.frame(
"sequence_1" = c("H. influenzae", "MuPhage", "H. influenzae"),
"e_value" = c("1e-09", "2e-10", "9e-08"),
"percent_identity" = c(27.10, 26.32, 27.66),
"sequence_2" = c("D. vulgaris", "MuPhage", "D. vulgaris")
)
# Create a Kable table for this blast_mu data
blast_mu %>%
knitr::kable(
digits = 2,
col.names = c("Sequence 1",
"E Value",
"Percent Identity",
"Sequence 2")
) %>%
kable_styling(font_size = 15)
# Save processed data
write.csv(blast_mu, '../data/data-processed/blast_mu.csv')
knitr::include_graphics("../images/align_dv.png")
knitr::include_graphics("../images/mugam_ring.png")
# Create a dataframe to compare the estimate molexular weights to those listed in ProtParam
mw <- data.frame(
"higam" = c(
"His13-HiGam Monomer",
"His13-HiGam Dimer",
"His7-HiGam Monomer",
"His7-HiGam Dimer"
),
"prot_param" = c("22491.54", "44983.08", "30626.50", "61253.00"),
"sds_page" = c(
sds$actual_weight[2], # Extracting MW from the SDS data
sds$actual_weight[2] * 2, # Multiply to get the dimer MW
sds$actual_weight[6],
sds$actual_weight[6] * 2 # Multiply to get the dimer MW
),
"sec" = c(NA, NA, (as.numeric(a280_mw) / 2), a280_mw) # MW estimated by SEC
)
# Make a Kabe table for the MW data
mw %>% knitr::kable(
caption = "Molecular weight was determined using Rf of bands and the linear regression equation acquired by the linear regression analysis of the MW ladder bands. Expected weights were obtained by ExPASy ProtParam.",
digits = 2,
col.names = c("HiGam",
"ProtParam",
"SDS-PAGE",
"SEC")
) %>%
kable_styling(font_size = 15)
# Save processed data
write.csv(mw, '../data/data-processed/mw.csv')
# Make a data frame comparing the binding footprint sizes estimated by EMSA and SEC
footprints <- data.frame(
"His7-Im9-HiGam" = c("Monomer", "Dimer"),
"EMSA" = c(emsa_footprint/2, emsa_footprint ), # Extracting EMSA footprints
"SEC" = c(NA, sec_footprint) # Extracting SEC footprint
)
# Make a Kable table for the footprint estimates
footprints %>% knitr::kable(
caption = "Comparison of the estimate DNA footprints for Im9-HiGam obtained from EMSA and SEC analysis. EMSAâs result was doubled to obtain the dimer value. The result of SEC proposes HiGam is a dimer.",
digits = 2,
col.names = c("His7-Im9-HiGam",
"EMSA",
"SEC")
) %>%
kable_styling(font_size = 15)
# Save processed data
write.csv(footprints, '../data/data-processed/footprints.csv')
RefManageR::PrintBibliography(refs)
RefManageR::PrintBibliography(pkgs)
Cite(refs, "Fuller2017-ex")
Cite(refs, "Fuller2017-ex")
Citep(refs, "Fuller2017-ex")
Cite(refs, textual = TRUE, "Fuller2017-ex")
